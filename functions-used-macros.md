Title: Функции в Assembler с помощью макросов. Локальные переменные
Summary: Создание функций в Assembler masm32 с использованием макрокоманд. Локальные переменные.
Date: 2020-12-13
Author: rate1  
Category: Assembler
Tags: assembler, masm32, макросы, функции, локальные переменные
Slug: funkcii-pri-pomoshi-makrosov
Status: published

##Функции с использованием макро-команд    
Макросы позволяют сократить количество кода. Макро-команды фактически состоят из нескольких команд, что можно увидеть через отладчик. Для примера создадим функцию, которая будет возвращать разность двух чисел, переданных ей в виде параметров.  
###Полный листинг программы с использованием макро-команд  
{% codeblock %}
.586P
.model flat,stdcall
;-------------------------------------
includelib C:\masm32\lib\kernel32.lib

extern ExitProcess@4:near
;-------------------------------------
SubProc PROTO :DWORD, :DWORD

_DATA SEGMENT
	ExitCode dd 0
	dwNum_1  dd 0
	dwNum_2  dd 0
	dwResult dd 0
_DATA ENDS

_TEXT SEGMENT
START:

	mov dwNum_1, 5
	mov dwNum_2, 10

	invoke SubProc, dwNum_1, dwNum_2
	mov dwResult, eax

	push [ExitCode]
	call ExitProcess@4
;-------------------------------------
SubProc proc num1:DWORD, num2:DWORD
	mov eax, num1
	sub eax, num2
	ret
SubProc endp

_TEXT ENDS
END START
{% endcodeblock %}  
###Объявление прототипа функции  
В случае использования макро-команд необходимо объявить прототип функции:  
```
:::asm
SubProc PROTO :DWORD, :DWORD
```  
В прототипе указывается имя функции (в нашем случае SubProc) и **тип и количество параметров**. Параметры указываются через запятую (в примере указаны два параметра [типа DWORD]({filename}dvoichnie-chisla.md)). Обратите внимание, что имена параметров при объявлении прототипа функции указывать не нужно.  
###Тело функции  
```
:::asm
SubProc proc num1:DWORD, num2:DWORD
	mov eax, num1
	sub eax, num2
	ret
SubProc endp
```  
При объявлении функции помимо типа параметров указываются имена параметров (num1 и num2 типа DWORD).  
Обратите внимание, что при таком подходе, нет необходимости заботиться о сохранности значений регистров ESP и EBP, как мы делали это при [создании обычной функции в Assembler, без использования макросов]({filename}functions-in-assembler.md).  
В самом теле функции происходит вычитание второго параметра из первого с помещением результата в регистр EAX (традиционно используемый для возврата значения из функции).  
Инструкция **ret** теперь также не требует добавления количества байт, занимаемых переданными в функцию параметрами, т.к. контроль за стеком полностью возлагается на макросы.  
###Вызов функции с помощью макросов  
При использовании макро-команд нельзя осуществить вызов функции при помощи команды **call***, необходимо использовать команду **invoke**.  
{% blockquote %}
invoke - вызывать
{% endblockquote %}  
Передача параметров в функцию осуществляется при вызове процедуры (напомню, что без использования макросов, мы передавали параметры в функцию путем их помещения в стек):  
```
:::asm
invoke SubProc, dwNum_1, dwNum_2
```  
###Взгляд на функцию Assembler "на макросах" через отладчик  
Функция SubProc, созданная нами, начинается с адреса 00401035:  

![Функция с использованием макро-команд в отладчике](/images/macro-function.jpg "Функция на Assembler с использованием макросов")  

Функция начинается с команд, которые были подставлены автоматически, это известные уже нам команды для сохранения стека в первоначальном состоянии:  
```
:::asm
push ebp
mov ebp, esp
```  
За ними следуют команды, которые мы писали, для вычитания второго параметра из первого. Сами параметры берутся из стека, используя смещение относительно значения регистра **EBP** (подход абсолютно такой же, как использовали мы, при написании функции без макросов).  
А после вычитания следует команда **LEAVE**, так же подставленная автоматически.  
{% blockquote %}
leave - покинуть
{% endblockquote %}
Команда **LEAVE** обеспечивает сохранение стека в изначальном состоянии и представляет из себя совокупность двух команд:
```
:::asm
mov esp, ebp
pop ebp
```  
##Локальные переменные  
Локальные переменные - это переменные, доступные только внутри функции. Этим они отличаются от глобальных переменных, которые определяются в сегменте данных (_DATA) и доступны во всем коде программы.  
###Локальные переменные в "классической" функции Assembler  
```
:asm
AddProc proc
	push ebp
	mov ebp, esp
	sub esp, 8
	;-----------------------------
	mov dword ptr[ebp-4], 22h
	mov dword ptr[ebp-8], 33h
	;-----------------------------
	push ebx
	push esi
	push edi
	;-----------------------------
	mov eax, dword ptr[ebp+8]
	add eax, dword ptr[ebp+0ch]
	;-----------------------------
	pop edi
	pop esi
	pop ebx
	mov esp, ebp
	pop ebp
	ret 8
AddProc endp
```  
Указатель на вершину стека, регистр **ESP** сдвигается вверх стека на 8 байт командой ```sub esp, 8```, освобождая тем самым место под две локальные переменные типа DWORD (по 4 байта каждая).  
После сдвига указателя в стек помещаются две локальные переменные со значениями 22h и 33h. Делается это с помощью команд:  
```
:asm
	mov dword ptr[ebp-4], 22h
	mov dword ptr[ebp-8], 33h
```  
Локальные переменные размещены в стеке и можно их использовать для вычислений внутри функции AddProc.  
###Локальные переменные в функции Assembler на макро-командах  
```
:::asm
SubProc proc num1:DWORD, num2:DWORD
	LOCAL a:DWORD
	LOCAL b:DWORD

	mov a, 44h
	mov b, 55h
	mov eax, num1
	sub eax, num2
	ret
SubProc endp
```  
При использовании макросов объявление локальных переменных происходит при помощи директивы **LOCAL**. Если посмотреть через отладчик, то можно обнаружить, что эта директива выполняет теже самые действия, что мы делали выше вручную, для определения локальных переменных:  

![Локальные переменные, объявленные через макрос LOCAL](/images/local-variables.jpg "Локальные переменные, объявленные через макрос LOCAL, взгляд через отладчик")  

Размещение значений локальных переменных в стек абсолютно идентично тому, как мы это делали вручную выше. Есть только одно синтаксическое отличие в этих двух вариантах объявления локальных переменных - при использовании макросов сдвиг значения регистра **ESP** осуществляется с помощью команды ```add esp, -8```, вместо использованной нами команды ```sub esp, 8```.  
