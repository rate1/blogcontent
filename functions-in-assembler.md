Title: Функции в Assembler
Summary: Функции в Assembler masm32. Вызов функции, передача параметров в функцию, возвращение результата из функции.
Date: 2020-12-12
Author: rate1  
Category: Assembler
Tags: assembler, masm32, функция
Slug: functions-in-assembler
Status: published

##Переменные для передачи аргументов в функцию  
Для примера создадим функцию, которая будет получать два числа и возвращать их сумму. Определим три переменные в сегменте _DATA: две для получения входных параметров и одну для результата работы функции:  
```
:::asm
_DATA SEGMENT
	ExitCode  dd 0
	dwNum_1   dd 0
	dwNub_2   dd 0
	dwResult  dd 0
_DATA ENDS
```
Первая переменная **ExitCode** используется для передачи в функцию выхода из программы ExitProcess, ноль означает корректное закрытые. Переменные dwNum_1 и dwNum_2 - это наши входные параметры, переменная dwResult - для хранения результата работы функции. dd - обозначает тип создаваемых переменных (double word) что соответствует 32 битам. Типы данных в masm32 рассмотрены в статье [Двоичные числа в Assembler]({filename}dvoichnie-chisla.md). Все 4 переменные, созданные в примере выше инициализированы значением 0, если начальное значение переменной не имеет значения, то можно инициализировать переменную значением ?.  
##Создание тела функции в Assembler masm32  
Тело функции должно находиться после инструкции выхода из программы.  
Процедуры определяются с помощью директывы **proc**. Конец тела функции определяются с помощью директывы **endp**:  
```
:::asm
AddProc proc

AddProc endp
```  
В примере **AddProc** - это имя процедуры, которую мы создаем.  
##Передача параметров в функцию через стек  
Параметры в функции в Assembler передаются через **стек**. Параметры помещаются в стек в обратном порядке (от последнего к первому), делается это потому, что получение значений из стека идет по принципу "первый пришел - последний ушел". После каждого помещения параметра в стек значение регистра **ESP** уменьшается на 4 байта (регистр ESP указывает на вершину стекa):  

 ![Добавление параметра функции в стек](/images/push_parametr-in-stack.jpg "Добавление параметра функции в стек")  

После каждого добавления параметра в стек происходит сдвиг регистра ESP на 4 байта, т.е. команду **PUSH** можно представить как совокупность двух команд:  
```
:::asm
sub ESP, 4
mov [ESP], arg
```  
Первой командой значение регистра ESP уменьшается на 4 байта, а второй командой происходит помещение в стек (квадратные скобки означают помещение значения по указанному в скобках адресу) значения аргумента arg:  

![В стек добавлены все аргументы функции](/images/stack-and-parametrs.jpg "В стек помещены все аргументы для функции")  

Как мы уже узнали, параметры функции помещаются в стек в обратном порядке. После команд push следует команда вызова функции call:  
```
:::asm
START:
	push dwNum_2
	push dwNum_1
	call AddProc

	push [ExitCode]
	call ExitProcess@4
```  
В отладчике этот кусочек кода будет выглядет так:  

![Помещение параметров в стек в отладчике](/images/parametrs-in-stack.jpg "Помещение параметров в стек в отладчике")  

В первых двух командах **push**, как видно на скриншоте, отсутствуют имена переменных, зато вместо них есть адрес в памяти, по которому хранится значение этой переменной (DS означает сегмент данных). В отладчике можно наблюдать как меняется значение по указанному адресу.  
Перед тем как вызвать процедуру AddProc, выполняется еще одно действие - в стек помещается **адрес возврата**. Адрес возврата - это адрес инструкции, которая следует сразу за вызовом процедуры **call**. Делается это для того, чтобы процессор знал, какую инструкцию выполнять после выхода из процедуры:  

![В стек помещается адрес возврата из функции](/images/adres-vozvrata.jpg "В стек помещается адрес возврата из функции")  

Команду **CALL** можно представить как совокупность двух команд: сначала в стек помещается адрес возврата командой push, а после этого происходит переход на адрес вызванной процедуры.  
##Извлечение значений параметров в функции  
Так как поверх параметров в стек было добавлено значение адреса возврата, то получить доступ к параметрам при помощи команды **pop** не получится. Использовать регистр ESP напрямую также не получится, т.к. это приведет к изменению его значения и соответственно к потере данных в стеке. Для этих целей используется регистр **EBP**. Для начала, чтобы не потерять текущее значение, значение регистра EBP помещается в стек. После чего в регистр EBP помещается значение регистра ESP, т.е. регистр EBP начинает указывать на вершину стека.  
```
:::asm
push ebp
mov ebp, esp
```   
Далее в стек могу помещаться значения локальных переменных для функции (что соответственно приведет к изменению значения регистра ESP), но с помощью значения регистра EBP мы сможем получить доступ как к параметрам функции, так и к значениям локальных переменных. Если к значению регистра EBP прибавить смещение 8, то мы получим указатель на первый параметр функции, если прибавить 12, то получим указатель на второй параметр функции и т.д. Если из значения регистра EBP вычесть 4, то получим указатель на первую локальную переменную функции, если вычесть 8, то получим указатель на вторую локальную переменную функции и т.д.:  

![Доступ к параметрам функции](/images/dostup-k-parametram.jpg "Доступ к значениям параметров функции")  
##Восстановление значений регистров ESP и EBP  
После того, как функция завершит свою работу, необходимо восстановить значения регистров ESP и EBP к их значениям, до вызова процедуры, это делается с помощью двух команд:  
```
:::asm
mov esp, ebp
pop ebp
```  
С помощью первой команды восстанавливается значение регистра ESP и он начинает указывать на вершину стека, как на рисунке:  

![Восстановление значения регистра ESP](/images/vosstanovlenie-esp.jpg "Восстановление значения регистра ESP из EBP")  

Команда ```pop ebp``` вытаскивает из стека значение регистра EBP до вызова процедуры и кладет его в регистр EBP, кроме этого происходит смещение значения регистра ESP на 4 байта и он начинает указывать на адрес возврата из функции:  

![Восстановление значения регистра EBP](/images/vosstanovlenie-ebp.jpg "Восстановление значения регистра EBP из стека")  
##Возврат из функции  
После восстановления значения регистров необходимо осуществить возврат из функции, для этого предназначена команда ***RET***:  

![Возврат из функции](/images/vozvrat-iz-funkcii.jpg "Возврат из функции с помощью инструкции RET")  

Инструкция **RET** осуществляет переход на адрес возврата из стека и одновременно смещает значение регистра ESP на N\*4 байт, где N - это количество параметров, переданных в функцию. После этого регистр ESP начинает вновь указывать на дно стека, как было до вызова функции.  
В нашем случае инструкция **RET** будет выглядеть как ```ret 8```, т.к. мы передавали два параметра, по 4 байта каждый.  
##Наполнение тела функции  
* Помимо регистров ESP и EBP необходимо следить за сохранностью значений еще трех регистров: **EBX, ESI, EDI**. Для этой цели значения этих регистров прячутся в стек, подобно регистру EBP и восстанавливаются из стека перед выходом из функции.  
* По стандарту для возвращения значения из функции используется регистр **EAX** (это не является обязательным условием).  
```
:::asm
AddProc proc
	push ebp
	mov ebp, esp
	push ebx
	push esi
	push edi
	;--------------------------
	mov eax, dword ptr[ebp+8]
	mov ebx, dword ptr[ebp+0ch]
	add eax, ebx
	;--------------------------
	pop edi
	pop esi
	pop ebx
	mov esp, ebp
	pop ebp
	ret 8
AddProc endp
```
В теле функции в регистры **EAX** и **EBX** перемещаются значения параметров, полученные из стека с помощью смещений на 8 и 12 байт. После чего результат сложения этих двух значений помещается в регистр **EAX**. Заготовку тела функции (без сложения чисел) сразу добавляю в свой [список сниппетов для файлов расширения .asm редактора vim]({filename}snippets-for-vim.md).  
##Полный листинг программы  
```
:::asm
.586P
.model flat, stdcall
;-------------------------------------
includelib C:\masm32\lib\kernel32.lib

extern ExitProcess@4:near
;-------------------------------------

_DATA SEGMENT
    ExitCode dd 0
    dwNum_1  dd 0
    dwNum_2  dd 0
    dwResult dd 0
_DATA ENDS

_TEXT SEGMENT
START:
	mov dwNum_1, 5
	mov dwNum_2, 10

	push dwNum_2
	push dwNum_1
	call AddProc
	mov dwResult, eax

	push [ExitCode]
	call ExitProcess@4
;-------------------------------------
AddProc proc
	push ebp
	mov ebp, esp
	push ebx
	push esi
	push edi
	;-----------------------------
	mov eax, dword ptr[ebp+8]
	mov ebx, dword ptr[ebp+0ch]
	add eax, ebx
	;-----------------------------
	pop edi
	pop esi
	pop ebx
	mov esp, ebp
	pop ebp
	ret 8
AddProc endp

_TEXT ENDS
END START
```  
В отладчике программа будет выглядеть вот так:  

![Функция сложения в отладчике](/images/full-function.jpg "Функция сложения двух чисел в отладчике")  

[Способ создания функций с использованием макро-команд рассмотрен в следующем посте.]({filename}functions-used-macros.md)  
